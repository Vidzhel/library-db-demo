# МЕТОДИЧНІ РЕКОМЕНДАЦІЇ
## до лабораторної роботи
# "ІНТЕГРАЦІЯ SQL SERVER З .NET ДОДАТКАМИ ЧЕРЕЗ ADO.NET"
### .NET 9 + SQL Server

---

## ЗМІСТ

1. [Практичні завдання](#2-практичні-завдання)
2. [Методичні рекомендації](#3-методичні-рекомендації)
3. [Формат здачі та загальні вимоги](#4-формат-здачі-та-загальні-вимоги)

---

Тема: Інтеграція SQL Server з .NET додатками через ADO.NET
Мета: Освоєння практичних навичок інтеграції баз даних SQL Server з .NET додатками через низькорівневий провайдер Microsoft.Data.SqlClient. Розуміння принципів роботи з базами даних на фундаментальному рівні, що є основою для роботи з будь-якими ORM фреймворками.

Після виконання лабораторної роботи студент зможе:

- Налаштовувати підключення до SQL Server через connection strings
- Безпечно зберігати конфіденційні дані (паролі, connection strings) через User Secrets
- Створювати та виконувати параметризовані SQL запити для захисту від SQL injection
- Виконувати CRUD операції з використанням SqlCommand та SqlDataReader
- Використовувати транзакції для забезпечення цілісності даних
- Працювати з асинхронними операціями та CancellationToken
- Оптимізувати роботу з базою даних через connection pooling
- Реалізовувати складні сценарії інтеграції (stored procedures, bulk operations, різні рівні ізоляції)
- Вимірювати та аналізувати продуктивність операцій з базою даних

---

## 1. ПРАКТИЧНІ ЗАВДАННЯ

### Завдання 1: Налаштування проєкту та міграції схеми (15 балів)

**Опис:**
Створення .NET проєкту з підключенням до SQL Server та реалізація системи версіонування схеми бази даних через SQL міграції.

**Вимоги до виконання:**

1. Створити консольний .NET проєкт
2. Додати пакет Microsoft.Data.SqlClient
3. Налаштувати connection string через User Secrets (НЕ в appsettings.json!)
4. Створити SQL-скрипти міграцій для обраної предметної області:
   - Мінімум 3-5 таблиць
   - Правильні типи даних для кожної колонки
   - Primary keys та foreign keys
   - CHECK constraints для валідації
   - Індекси для оптимізації
5. Реалізувати MigrationRunner, який:
   - Створює таблицю для відстеження версій міграцій
   - Обчислює SHA256 хеш кожного міграційного файлу
   - Виконує міграції послідовно
   - Пропускає вже виконані міграції
   - Зберігає інформацію про застосовані міграції
   - Забезпечує ідемпотентність (можна запускати повторно)

**Критерії оцінювання:**

- Правильна структура проєкту та налаштування connection string через User Secrets (3 бали)
- SQL-скрипти міграцій з правильними типами даних, constraints, індексами (4 бали)
- Робочий MigrationRunner з версіонуванням та хешуванням (5 балів)
- Ідемпотентність міграцій та обробка помилок (3 бали)

**Документи для вивчення:**
- 01-project-setup.md - налаштування проєкту та User Secrets
- 04-database-schema.md - проектування схеми бази даних
- 05-migration-runner.md - реалізація системи міграцій

---

### Завдання 2: Repository Pattern та базові CRUD операції (25 балів)

**Опис:**
Реалізація паттерну Repository для доступу до даних з використанням параметризованих запитів та асинхронних операцій.

**Вимоги до виконання:**

1. Створити інтерфейс репозиторію для основної сутності предметної області
2. Реалізувати інтерфейс з наступними методами:
   - `CreateAsync` - створення нового запису з поверненням згенерованого ID
   - `GetByIdAsync` - отримання запису за первинним ключем
   - `GetAllAsync` - отримання всіх записів
   - `UpdateAsync` - оновлення існуючого запису
   - `DeleteAsync` - видалення запису
3. Всі SQL запити мають використовувати параметри (SqlParameter) - БЕЗ конкатенації рядків!
4. Всі методи мають бути асинхронними з підтримкою CancellationToken
5. Правильно закривати ресурси через `await using` statements
6. Обробляти null значення при читанні з SqlDataReader

**Критерії оцінювання:**

- Правильна архітектура: інтерфейс + реалізація, dependency injection (5 балів)
- Параметризовані запити, захист від SQL injection (6 балів)
- Всі п'ять CRUD методів реалізовані коректно, правильне зіставлення даних (8 балів)
- Async/await, CancellationToken, правильний resource management через await using (6 балів)

**Документи для вивчення:**
- 06-repository-pattern.md - Repository Pattern, CRUD операції, параметризовані запити

---

### Завдання 3: Складні запити та пагінація (10 балів)

**Опис:**
Розширення репозиторію методами для складних запитів з фільтрацією, сортуванням, пагінацією та JOIN операціями.

**Вимоги до виконання:**

1. Реалізувати метод `GetPagedAsync` з параметрами:
   - `pageNumber` - номер сторінки (починаючи з 1)
   - `pageSize` - кількість записів на сторінці
   - `sortBy` - назва колонки для сортування
   - `sortDirection` - напрямок сортування (ASC/DESC)
   - `filterValue` - опціональний параметр для фільтрації
2. Використовувати SQL конструкцію OFFSET-FETCH для пагінації
3. Реалізувати метод з JOIN між мінімум двома таблицями, що повертає комбіновані дані
4. Динамічне формування WHERE умов на основі переданих параметрів

**Критерії оцінювання:**

- Правильна реалізація OFFSET-FETCH пагінації з параметрами (4 бали)
- JOIN запити з правильним зіставленням об'єктів (3 бали)
- Динамічна фільтрація та сортування через параметри (3 бали)

**Документи для вивчення:**
- 06-repository-pattern.md - складні запити, пагінація, JOIN операції

---

### Завдання 4: Транзакції та цілісність даних (20 балів)

**Опис:**
Реалізація багатокрокової операції з демонстрацією проблеми часткового виконання та її вирішення через транзакції.

**Вимоги до виконання:**

1. **Реалізувати ту саму операцію З транзакцією:**
   - Використати `BeginTransactionAsync` для початку транзакції
   - Виконати всі операції в межах однієї транзакції
   - При успіху викликати `CommitAsync`
   - При помилці викликати `RollbackAsync`
   - Показати що тепер при помилці ВСІ зміни скасовуються

2. Правильна обробка помилок через try-catch-finally блоки

**Приклади багатокрокових операцій:**
- Створення замовлення: додавання заголовка + додавання позицій + зменшення залишків на складі
- Переказ коштів: зняття з одного рахунку + додавання на інший + запис в історію
- Реєстрація користувача: створення запису + додавання ролей + відправка email

**Критерії оцінювання:**

- Пояснення проблеми часткового виконання без транзакції на власному проєкті (можна описати словесно) (5 балів)
- Правильна реалізація транзакції з CommitAsync та RollbackAsync (10 балів)
- Обробка помилок, коректне використання try-catch-finally (5 балів)

**Документи для вивчення:**
- 13-transaction-problem.md - демонстрація проблеми без транзакцій
- 14-transactions.md - правильне використання транзакцій

---

### Завдання 5: На вибір студента (15 балів)

**Студент обирає ОДИН з трьох варіантів:**

#### Варіант A: Connection Pooling та продуктивність

**Опис:** Дослідження впливу connection pooling на продуктивність роботи з базою даних.

**Вимоги:**
1. Створити тестовий метод який виконує 100 простих запитів (наприклад, SELECT 1)
2. Запустити тест З увімкненим pooling (за замовчуванням)
3. Запустити тест БЕЗ pooling (додати `Pooling=false` до connection string)
4. Виміряти час виконання для обох варіантів
5. Налаштувати різні параметри пулу (Min Pool Size, Max Pool Size)
6. Створити порівняльну таблицю результатів
7. Написати висновки про вплив pooling на продуктивність

**Критерії оцінювання:**
- Налаштування та реалізація тестів (3 бали)
- Коректне вимірювання часу виконання (6 балів)
- Аналіз результатів та висновки (6 балів)

**Документи для вивчення:** 09-connection-pooling.md

---

#### Варіант B: Stored Procedures та їх виклик з C#

**Опис:** Створення stored procedure з бізнес-логікою та її виклик з .NET коду.

**Вимоги:**
1. Створити stored procedure яка реалізує певну бізнес-логіку вашої предметної області
2. Використати INPUT параметри для передачі даних в процедуру
3. Використати OUTPUT параметри для повернення додаткових значень
4. Використати RETURN код для індикації успіху/помилки
5. Викликати процедуру з C# коду:
   - Налаштувати SqlCommand з CommandType.StoredProcedure
   - Передати INPUT параметри
   - Отримати OUTPUT параметри та return code
   - Обробити результати (якщо процедура повертає result set)

**Критерії оцінювання:**
- Створення stored procedure з бізнес-логікою (5 балів)
- Правильна робота з INPUT/OUTPUT параметрами (5 балів)
- Виклик з C# коду та обробка результатів (5 балів)

**Документи для вивчення:** 17-stored-procedures.md

---

#### Варіант C: Масові операції (SqlBulkCopy)

**Опис:** Порівняння продуктивності різних підходів до масової вставки даних.

**Вимоги:**
1. Створити метод генерації тестових даних (мінімум 1000 записів)
2. Реалізувати вставку через звичайні INSERT в циклі
3. Реалізувати вставку через batched INSERT (групування по 50-100 записів)
4. Реалізувати вставку через SqlBulkCopy
5. Виміряти час виконання для кожного підходу
6. Налаштувати BatchSize для SqlBulkCopy та побачити його вплив
7. Створити порівняльну таблицю результатів
8. Написати висновки про застосування кожного підходу

**Критерії оцінювання:**
- Реалізація SqlBulkCopy з правильним зіставленням колонок (6 балів)
- Порівняння трьох підходів з вимірюванням часу (5 балів)
- Аналіз результатів та рекомендації (4 бали)

**Документи для вивчення:** 10-sql-bulk-copy.md

---

### Завдання 6: На вибір студента (15 балів)

**Студент обирає ОДИН з двох варіантів:**

#### Варіант A: Рівні ізоляції транзакцій (практика)

**Опис:** Практичне дослідження різних рівнів ізоляції транзакцій та їх впливу на конкурентний доступ до даних.

**Вимоги:**
1. Створити демонстрацію для кожного рівня ізоляції:
   - Read Uncommitted
   - Read Committed (за замовчуванням)
   - Repeatable Read
   - Serializable
2. Для кожного рівня показати:
   - Як він запобігає або дозволяє dirty reads
   - Як він запобігає або дозволяє non-repeatable reads
   - Як він запобігає або дозволяє phantom reads
3. Створити сценарій deadlock:
   - Дві транзакції які блокують одна одну
   - Показати як SQL Server вибирає victim
   - Запропонувати спосіб уникнення deadlock
4. Написати висновки про вибір рівня ізоляції для різних сценаріїв

**Критерії оцінювання:**
- Демонстрація чотирьох рівнів ізоляції з поясненнями (8 балів)
- Практичні сценарії dirty/phantom/non-repeatable reads (4 бали)
- Deadlock сценарій та його вирішення (3 бали)

**Документи для вивчення:** 14-transactions.md

---

#### Варіант B: Асинхронність та cancellation (поглиблено)

**Опис:** Поглиблене вивчення асинхронних операцій з підтримкою відміни та таймаутів.

**Вимоги:**
1. Створити метод який виконує довгу операцію (використати WAITFOR DELAY '00:00:05' в SQL)
2. Реалізувати підтримку CancellationToken:
   - Створити CancellationTokenSource з автоматичним таймаутом
   - Передати токен в усі async методи (OpenAsync, ExecuteReaderAsync, ReadAsync)
   - Обробити OperationCanceledException
3. Реалізувати manual cancellation:
   - Дозволити користувачу скасувати операцію (наприклад, натиснувши клавішу)
   - Показати коректне завершення операції
4. Реалізувати parallel виконання кількох запитів:
   - Використати Task.WhenAll для паралельного виконання
   - Обробити сценарій коли один із запитів падає
5. Написати висновки про переваги async/await та cancellation

**Критерії оцінювання:**
- CancellationToken з timeout та manual cancellation (6 балів)
- Parallel виконання запитів через Task.WhenAll (5 балів)
- Правильна обробка OperationCanceledException (4 бали)

**Документи для вивчення:** 06-repository-pattern.md (секція про async/await)

---

## 2. МЕТОДИЧНІ РЕКОМЕНДАЦІЇ

### 2.1. Що таке ADO.NET?

ADO.NET (ActiveX Data Objects for .NET) - це низькорівневий провайдер доступу до даних в .NET екосистемі. Він забезпечує фундаментальний інтерфейс для взаємодії з базами даних через підключення, команди та читачі даних.

**Ключові відмінності від ORM (Entity Framework Core):**

- Повний контроль над SQL запитами - SQL пишеться вручну
- Вища продуктивність для критичних операцій - немає overhead від ORM
- Відсутність абстракції - робота безпосередньо з SQL та результатами
- Необхідність вручну зіставляти дані з SqlDataReader в об'єкти
- Більше коду, але більше контролю

**Коли використовувати ADO.NET:**
- Критичні за продуктивністю операції
- Складні SQL запити які важко виразити через LINQ
- Масові операції (bulk insert, bulk update)
- Робота з stored procedures
- Legacy системи де ORM не підтримується

### 2.2. Microsoft.Data.SqlClient

Сучасний провайдер для SQL Server, який замінив застарілий System.Data.SqlClient. Активно підтримується Microsoft та має всі нові можливості SQL Server.

**Встановлення:**
```bash
dotnet add package Microsoft.Data.SqlClient
```

**Основні переваги:**
- Підтримка нових функцій SQL Server
- Активна розробка та підтримка
- Краща продуктивність
- Підтримка Always Encrypted, Azure AD authentication

### 2.3. Основні компоненти ADO.NET

#### SqlConnection

Встановлює з'єднання з базою даних. Налаштовується через connection string.

**Ключові моменти:**
- Завжди потрібно використовувати `await using` для автоматичного закриття
- Connection string може містити параметри pooling
- З'єднання дороге - потрібно відкривати пізно, закривати рано
- Pooling працює автоматично для однакових connection strings

**Приклад:**
```csharp
await using var connection = new SqlConnection(connectionString);
await connection.OpenAsync(cancellationToken);
```

#### SqlCommand

Виконує SQL команди або stored procedures.

**Методи виконання:**
- `ExecuteNonQueryAsync` - для INSERT/UPDATE/DELETE, повертає кількість змінених рядків
- `ExecuteScalarAsync` - для запитів що повертають одне значення (COUNT, SUM, тощо)
- `ExecuteReaderAsync` - для SELECT запитів, повертає SqlDataReader

**Параметри:**
- `CommandText` - SQL запит або назва stored procedure
- `CommandType` - Text (за замовчуванням) або StoredProcedure
- `CommandTimeout` - таймаут виконання в секундах

#### SqlDataReader

Forward-only, read-only курсор для читання результатів SELECT запитів.

**Характеристики:**
- Дуже швидкий та ефективний по пам'яті
- Може читати тільки вперед (forward-only)
- Read-only - не можна змінювати дані
- Асинхронні методи: ReadAsync, GetFieldValueAsync
- Завжди потрібно закривати після використання

**Читання даних:**
```csharp
while (await reader.ReadAsync(cancellationToken))
{
    int id = reader.GetInt32(0);
    string name = reader.GetString(1);
    decimal? price = reader.IsDBNull(2) ? null : reader.GetDecimal(2);
}
```

#### SqlTransaction

Керує транзакціями для забезпечення ACID властивостей.

**Lifecycle транзакції:**
1. `BeginTransactionAsync` - початок транзакції
2. Виконання SQL команд
3. `CommitAsync` - фіксація змін (при успіху)
4. `RollbackAsync` - відміна змін (при помилці)

**Рівні ізоляції:**
- ReadUncommitted - найшвидший, дозволяє dirty reads
- ReadCommitted - за замовчуванням в SQL Server
- RepeatableRead - запобігає non-repeatable reads
- Serializable - найвища ізоляція
- Snapshot - версіонування рядків

**Детальна інформація:** Документи 13-transaction-problem.md, 14-transactions.md

### 2.4. Параметризовані запити (КРИТИЧНО ВАЖЛИВО!)

**Проблема SQL Injection:**

SQL injection - це одна з найнебезпечніших вразливостей веб-додатків. Виникає коли користувацький ввід напряму конкатенується в SQL запит.

**НЕПРАВИЛЬНО (НІКОЛИ ТАК НЕ РОБИТИ!):**
```csharp
// ВСЯ СТАТТЯ МОЖЕ БУТИ SQL INJECTION!
string sql = $"SELECT * FROM Users WHERE Name = '{userInput}'";
```

Якщо користувач введе: `admin' OR '1'='1`, то запит стане:
```sql
SELECT * FROM Users WHERE Name = 'admin' OR '1'='1'
```
Це поверне всіх користувачів!

**ПРАВИЛЬНО - використання параметрів:**
```csharp
string sql = "SELECT * FROM Users WHERE Name = @name";
cmd.Parameters.AddWithValue("@name", userInput);
```

SQL Server обробить це як буквальне значення, а не частину SQL коду.

**Переваги параметризованих запитів:**
- Захист від SQL injection
- Підвищення продуктивності (query plan caching)
- Правильна обробка типів даних
- Автоматичне екранування спеціальних символів

**Детальна інформація:** Документ 06-repository-pattern.md

### 2.5. Connection Pooling

ADO.NET автоматично використовує пул з'єднань (connection pool) для підвищення продуктивності.

**Як працює pooling:**

1. Перший раз коли відкривається з'єднання - створюється фізичне з'єднання з БД
2. При закритті з'єднання (Dispose) - воно НЕ закривається фізично, а повертається в пул
3. Наступний запит з таким самим connection string - отримує з'єднання з пулу
4. Це економить час на встановлення TCP з'єднання та аутентифікацію

**Параметри pooling:**
```
Min Pool Size=0        // мінімальна кількість з'єднань в пулі
Max Pool Size=100      // максимальна кількість з'єднань
Pooling=true          // увімкнення/вимкнення pooling
```

**Вплив на продуктивність:**
- З pooling: ~5-10 мс на запит
- Без pooling: ~50-100 мс на запит (відкриття з'єднання кожен раз)
- Різниця: 10-20x прискорення!

**Важливо:**
- Завжди потрібно закривати з'єднання (через using або Dispose)
- Однаковий connection string = той самий пул
- Не можна зберігати відкриті з'єднання - це витікання ресурсів
- `Pooling=false` використовується тільки для тестування впливу pooling

**Детальна інформація:** Документ 09-connection-pooling.md

### 2.6. Транзакції та ACID властивості

**ACID - чотири властивості надійних транзакцій:**

- **Atomicity (Атомарність)** - транзакція виконується повністю або не виконується взагалі. Немає "часткового виконання".
- **Consistency (Узгодженість)** - дані залишаються в валідному стані до і після транзакції. Всі constraints виконуються.
- **Isolation (Ізоляція)** - конкурентні транзакції не впливають одна на одну (залежить від рівня ізоляції).
- **Durability (Довговічність)** - після commit зміни зберігаються навіть при збої системи.

**Коли використовувати транзакції:**

1. Багатокрокові операції що повинні виконатись разом
2. Операції що змінюють пов'язані дані
3. Критичні бізнес-операції (платежі, замовлення, трансфери)
4. Будь-яка операція де "все або нічого" критично важливо

**Приклад без транзакції (ПРОБЛЕМА):**
```
1. Зняти 100 грн з рахунку A ✓
2. ПОМИЛКА МЕРЕЖІ!
3. Додати 100 грн на рахунок B ✗ (не виконалось)

Результат: гроші зникли!
```

**З транзакцією (ВИРІШЕННЯ):**
```
BEGIN TRANSACTION
1. Зняти 100 грн з рахунку A ✓
2. ПОМИЛКА МЕРЕЖІ!
ROLLBACK - обидві операції скасовані!

Результат: все залишилось як було
```

**Детальна інформація:** Документи 13-transaction-problem.md, 14-transactions.md

### 2.7. Асинхронне програмування з async/await

Всі основні операції ADO.NET мають асинхронні версії:
- `OpenAsync` - відкриття з'єднання
- `ExecuteNonQueryAsync` - виконання INSERT/UPDATE/DELETE
- `ExecuteScalarAsync` - виконання запиту з одним значенням
- `ExecuteReaderAsync` - виконання SELECT запиту
- `ReadAsync` - читання наступного рядка з SqlDataReader

**Переваги async/await:**
- Не блокує потоки під час I/O операцій (читання/запис в БД)
- Покращує масштабованість додатка (більше конкурентних запитів)
- Підтримка cancellation через CancellationToken
- Краще використання ресурсів сервера

**CancellationToken:**

Дозволяє скасувати довгу операцію:
```csharp
var cts = new CancellationTokenSource();
cts.CancelAfter(TimeSpan.FromSeconds(5)); // автоматичний таймаут

try
{
    await connection.OpenAsync(cts.Token);
    await command.ExecuteReaderAsync(cts.Token);
}
catch (OperationCanceledException)
{
    // Операція була скасована
}
```

**Детальна інформація:** Документ 06-repository-pattern.md

### 2.8. Resource Management - правильне закриття ресурсів

**Проблема:**
SqlConnection, SqlCommand, SqlDataReader - це неуправляємі ресурси (unmanaged resources). Якщо їх не закрити - витікання пам'яті та вичерпання пулу з'єднань.

**Рішення - await using statement:**

```csharp
await using var connection = new SqlConnection(connectionString);
await using var command = new SqlCommand(sql, connection);
await using var reader = await command.ExecuteReaderAsync();
```

`await using` автоматично викликає `DisposeAsync` в кінці блоку, навіть якщо виникла помилка.

**Що відбувається при Dispose:**
- SqlConnection - повертається в пул (не закривається фізично)
- SqlCommand - очищає параметри та ресурси
- SqlDataReader - закриває курсор на сервері

**Без await using (ПОГАНО):**
```csharp
var connection = new SqlConnection(connectionString);
connection.Open();
// Забули викликати Dispose - витікання ресурсів!
```

---

## 3. ФОРМАТ ЗДАЧІ ТА ЗАГАЛЬНІ ВИМОГИ

### 3.1. Структура проєкту

Проєкт має мати наступну структуру:

```
YourProjectName/
├── migrations/                 # SQL-скрипти міграцій
│   ├── 001_initial_schema.sql
│   ├── 002_add_indexes.sql
│   └── ...
├── src/
│   ├── Models/                 # Класи моделей (POCO)
│   │   ├── Book.cs
│   │   ├── Category.cs
│   │   └── ...
│   ├── Repositories/           # Репозиторії для доступу до даних
│   │   ├── IBookRepository.cs
│   │   ├── BookRepository.cs
│   │   └── ...
│   ├── Services/               # Сервіси (MigrationRunner, тощо)
│   │   └── MigrationRunner.cs
│   └── Program.cs              # Точка входу, демонстрація
├── appsettings.json            # Конфігурація (БЕЗ паролів!)
├── README.md                   # Інструкції по запуску
└── REPORT.md                   # Звіт про виконану роботу
```

### 3.2. README.md

Файл README.md має містити:

1. **Назва проєкту та опис предметної області**
   - Коротко описати що робить система
   - Які сутності в базі даних

2. **Інструкції по налаштуванню**
   - Як встановити SQL Server (якщо потрібно)
   - Як налаштувати connection string через User Secrets
   - Які NuGet пакети потрібні

3. **Інструкції по запуску**
   - Як виконати міграції
   - Як запустити демонстрацію
   - Які команди використовувати

4. **Виконані завдання**
   - Список завдань 1-4 (обов'язкові)
   - Який варіант обрано для завдання 5
   - Який варіант обрано для завдання 6

### 3.3. REPORT.md

Файл REPORT.md має містити звіт про виконану роботу:

1. **Опис виконання кожного завдання**
   - Що було зроблено
   - Які складнощі виникли
   - Як вони були вирішені

2. **Скріншоти результатів виконання**
   - Результати виконання міграцій
   - Результати CRUD операцій
   - Результати транзакцій (до і після)
   - Графіки/таблиці продуктивності (де застосовно)

3. **Виміряні показники продуктивності**
   - Для завдання 5 (якщо обрано pooling або bulk copy)
   - Для завдання 6 (якщо обрано async/cancellation)

4. **Висновки та спостереження**
   - Що нового дізнались
   - Які підходи виявились найефективнішими
   - Рекомендації для практичного застосування

### 3.4. Вимоги до коду

**Стиль коду:**
- Професійний стиль (БЕЗ емоджі в коді)
- Змістовні назви змінних, методів та класів (англійською)
- Консистентне форматування (рекомендується використати IDE formatter)
- Коментарі українською або англійською для пояснення складної логіки

**Обов'язкові практики:**
- Всі SQL запити параметризовані (SqlParameter)
- Використання `await using` для ресурсів
- Async/await для всіх операцій з БД
- Обробка помилок через try-catch де потрібно
- Підтримка CancellationToken в асинхронних методах

**Чого уникати:**
- Конкатенації SQL рядків з користувацьким вводом
- Зберігання паролів в appsettings.json або коді
- Відкритих з'єднань без using
- Синхронних викликів (Open, ExecuteReader, тощо)
- SELECT * (завжди потрібно перераховувати колонки)

### 3.5. Загальні вимоги

**Технічні вимоги:**
- Проєкт має компілюватись без помилок та попереджень
- Міграції мають виконуватись успішно
- Демонстраційний код в Program.cs має працювати
- Connection string налаштовано через User Secrets

**Обов'язкові завдання:**
- Завдання 1: Налаштування та міграції ✓
- Завдання 2: Repository та CRUD ✓
- Завдання 3: Складні запити ✓
- Завдання 4: Транзакції ✓

**Завдання на вибір:**
- Завдання 5: Один варіант з трьох (A/B/C) ✓
- Завдання 6: Один варіант з двох (A/B) ✓

**Документація:**
- README.md з інструкціями ✓
- REPORT.md зі звітом ✓
